/*
 * This file is part of Tepl, a text editor library.
 *
 * Copyright 2020 - SÃ©bastien Wilmet <swilmet@gnome.org>
 *
 * Tepl is free software; you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation; either version 2.1 of the License, or (at your
 * option) any later version.
 *
 * Tepl is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library; if not, see <http://www.gnu.org/licenses/>.
 */

#include "tepl-metadata-store.h"
#include "tepl-metadata-store-loader.h"
#include "tepl-utils.h"

/**
 * SECTION:metadata-store
 * @Title: TeplMetadataStore
 * @Short_description: To store file metadata on disk
 *
 * #TeplMetadataStore permits to store file metadata on disk. It serves both as
 * an easier replacement for GVfs metadata, and to have metadata support on
 * platforms that don't support GVfs metadata.
 */

/* This code is inspired by TeplMetadataManager, which was itself a modified
 * version of GeditMetadataManager, coming from gedit:
 *
 * Copyright 2003-2007 - Paolo Maggi
 *
 * The XML format is the same. TeplMetadataStore can read a file generated by
 * TeplMetadataManager; but the reverse is maybe not true, it hasn't been
 * tested. Not tested either with the older GeditMetadataManager.
 *
 * A better implementation would be to use a database, so that several processes
 * can read and write to it at the same time, to be able to share metadata
 * between apps.
 */

struct _TeplMetadataStorePrivate
{
	/* Keys: GFile *
	 * Values: TeplFileMetadata *
	 * Never NULL.
	 */
	GHashTable *hash_table;

	guint modified : 1;
};

/* TeplMetadataStore is a singleton. */
static TeplMetadataStore *singleton = NULL;

#define DEFAULT_MAX_NUMBER_OF_LOCATIONS (1000)

G_DEFINE_TYPE_WITH_PRIVATE (TeplMetadataStore, tepl_metadata_store, G_TYPE_OBJECT)

static void
tepl_metadata_store_finalize (GObject *object)
{
	TeplMetadataStore *store = TEPL_METADATA_STORE (object);

	if (singleton == store)
	{
		singleton = NULL;
	}

	g_hash_table_unref (store->priv->hash_table);

	G_OBJECT_CLASS (tepl_metadata_store_parent_class)->finalize (object);
}

static void
tepl_metadata_store_class_init (TeplMetadataStoreClass *klass)
{
	GObjectClass *object_class = G_OBJECT_CLASS (klass);

	object_class->finalize = tepl_metadata_store_finalize;
}

static void
tepl_metadata_store_init (TeplMetadataStore *store)
{
	store->priv = tepl_metadata_store_get_instance_private (store);

	store->priv->hash_table = g_hash_table_new_full (g_file_hash,
							 (GEqualFunc) g_file_equal,
							 g_object_unref,
							 g_object_unref);
}

/**
 * tepl_metadata_store_get_singleton:
 *
 * Returns: (transfer none): the #TeplMetadataStore singleton instance.
 * Since: 5.0
 */
TeplMetadataStore *
tepl_metadata_store_get_singleton (void)
{
	if (singleton == NULL)
	{
		singleton = g_object_new (TEPL_TYPE_METADATA_STORE, NULL);
	}

	return singleton;
}

void
_tepl_metadata_store_unref_singleton (void)
{
	if (singleton != NULL)
	{
		g_object_unref (singleton);
	}

	/* singleton is not set to NULL here, it is set to NULL in
	 * tepl_metadata_store_finalize() (i.e. when we are sure that the ref
	 * count reaches 0).
	 */
}

/**
 * tepl_metadata_store_trim:
 * @store: the #TeplMetadataStore.
 * @max_number_of_locations: the maximum size, or -1 for the default value.
 *
 * The purpose of having a maximum size is to avoid that the store file grows
 * indefinitely.
 *
 * @max_number_of_locations is the maximum number of #GFile locations for which
 * metadata are kept. This function discards the least recently accessed
 * metadata if needed.
 *
 * If @max_number_of_locations is -1, a default internal value is used that
 * should fit most applications' needs.
 *
 * Since: 5.0
 */
void
tepl_metadata_store_trim (TeplMetadataStore *store,
			  gint               max_number_of_locations)
{
	guint my_max_number_of_locations;

	g_return_if_fail (TEPL_IS_METADATA_STORE (store));
	g_return_if_fail (max_number_of_locations >= -1);

	if (max_number_of_locations == -1)
	{
		my_max_number_of_locations = DEFAULT_MAX_NUMBER_OF_LOCATIONS;
	}
	else
	{
		my_max_number_of_locations = max_number_of_locations;
	}

	while (g_hash_table_size (store->priv->hash_table) > my_max_number_of_locations)
	{
		GHashTableIter iter;
		gpointer key;
		gpointer value;
		GFile *oldest_location = NULL;
		TeplFileMetadata *oldest_file_metadata = NULL;

		g_hash_table_iter_init (&iter, store->priv->hash_table);
		while (g_hash_table_iter_next (&iter, &key, &value))
		{
			GFile *location = key;
			TeplFileMetadata *file_metadata = value;

			if (oldest_location == NULL ||
			    _tepl_file_metadata_compare_atime (file_metadata, oldest_file_metadata) < 0)
			{
				oldest_location = location;
				oldest_file_metadata = file_metadata;
			}
		}

		g_hash_table_remove (store->priv->hash_table, oldest_location);
		store->priv->modified = TRUE;
	}
}

/**
 * tepl_metadata_store_load:
 * @store: the #TeplMetadataStore.
 * @from_file: the store file.
 * @error: location to a %NULL #GError, or %NULL.
 *
 * Loads synchronously the metadata from @from_file into @store.
 *
 * A good moment to call this function is on application startup, see the
 * #GApplication::startup signal.
 *
 * Returns: whether the operation was successful.
 * Since: 5.0
 */
gboolean
tepl_metadata_store_load (TeplMetadataStore  *store,
			  GFile              *from_file,
			  GError            **error)
{
	g_return_val_if_fail (TEPL_IS_METADATA_STORE (store), FALSE);
	g_return_val_if_fail (G_IS_FILE (from_file), FALSE);
	g_return_val_if_fail (error == NULL || *error == NULL, FALSE);

	return _tepl_metadata_store_loader (from_file,
					    store->priv->hash_table,
					    error);
}

static GBytes *
to_string (TeplMetadataStore *store)
{
	GString *string;
	GHashTableIter iter;
	gpointer key;
	gpointer value;

	string = g_string_new (NULL);
	g_string_append (string, "<metadata>\n");

	g_hash_table_iter_init (&iter, store->priv->hash_table);
	while (g_hash_table_iter_next (&iter, &key, &value))
	{
		GFile *location = key;
		TeplFileMetadata *file_metadata = value;

		_tepl_file_metadata_append_xml_to_string (file_metadata, location, string);
	}

	g_string_append (string, "</metadata>\n");

	return g_string_free_to_bytes (string);
}

/**
 * tepl_metadata_store_save:
 * @store: the #TeplMetadataStore.
 * @to_file: the store file.
 * @trim: if %TRUE, tepl_metadata_store_trim() is called with -1.
 * @error: location to a %NULL #GError, or %NULL.
 *
 * Saves synchronously the metadata from @store to @to_file. The parent
 * directories of @to_file are created if needed.
 *
 * A good moment to call this function is on application shutdown, see the
 * #GApplication::shutdown signal.
 *
 * Returns: whether the operation was successful.
 * Since: 5.0
 */
gboolean
tepl_metadata_store_save (TeplMetadataStore  *store,
			  GFile              *to_file,
			  gboolean            trim,
			  GError            **error)
{
	GBytes *bytes;
	gboolean ok;

	g_return_val_if_fail (TEPL_IS_METADATA_STORE (store), FALSE);
	g_return_val_if_fail (G_IS_FILE (to_file), FALSE);
	g_return_val_if_fail (error == NULL || *error == NULL, FALSE);

	if (trim)
	{
		tepl_metadata_store_trim (store, -1);
	}

	if (!store->priv->modified)
	{
		return TRUE;
	}

	if (!tepl_utils_create_parent_directories (to_file, NULL, error))
	{
		return FALSE;
	}

	bytes = to_string (store);

	ok = g_file_replace_contents (to_file,
				      g_bytes_get_data (bytes, NULL),
				      g_bytes_get_size (bytes),
				      NULL,
				      FALSE,
				      G_FILE_CREATE_NONE,
				      NULL,
				      NULL,
				      error);

	if (ok)
	{
		store->priv->modified = FALSE;
	}

	g_bytes_unref (bytes);
	return ok;
}

/**
 * tepl_metadata_store_load_file_metadata:
 * @store: the #TeplMetadataStore.
 * @location: a #GFile.
 * @file_metadata: a #TeplFileMetadata.
 *
 * Copies the metadata stored in @store for @location into @file_metadata.
 *
 * Since: 5.0
 */
void
tepl_metadata_store_load_file_metadata (TeplMetadataStore *store,
					GFile             *location,
					TeplFileMetadata  *file_metadata)
{
	TeplFileMetadata *file_metadata_from_store;

	g_return_if_fail (TEPL_IS_METADATA_STORE (store));
	g_return_if_fail (G_IS_FILE (location));
	g_return_if_fail (TEPL_IS_FILE_METADATA (file_metadata));

	file_metadata_from_store = g_hash_table_lookup (store->priv->hash_table, location);

	if (file_metadata_from_store != NULL)
	{
		_tepl_file_metadata_copy_into (file_metadata_from_store, file_metadata);
	}
}

/**
 * tepl_metadata_store_save_file_metadata:
 * @store: the #TeplMetadataStore.
 * @location: a #GFile.
 * @file_metadata: a #TeplFileMetadata.
 *
 * Copies the metadata from @file_metadata into @store for @location.
 *
 * Since: 5.0
 */
void
tepl_metadata_store_save_file_metadata (TeplMetadataStore *store,
					GFile             *location,
					TeplFileMetadata  *file_metadata)
{
	TeplFileMetadata *file_metadata_from_store;

	g_return_if_fail (TEPL_IS_METADATA_STORE (store));
	g_return_if_fail (G_IS_FILE (location));
	g_return_if_fail (TEPL_IS_FILE_METADATA (file_metadata));

	file_metadata_from_store = g_hash_table_lookup (store->priv->hash_table, location);

	if (file_metadata_from_store == NULL)
	{
		file_metadata_from_store = tepl_file_metadata_new ();

		g_hash_table_replace (store->priv->hash_table,
				      g_object_ref (location),
				      file_metadata_from_store);
	}

	_tepl_file_metadata_copy_into (file_metadata, file_metadata_from_store);

	store->priv->modified = TRUE;
}
